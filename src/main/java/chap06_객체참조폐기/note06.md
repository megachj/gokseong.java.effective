## 유효기간이 지난 객체 참조는 폐기해야 한다.
### 메모리 누수가 일어나는 이유
> 만기 참조: 다시 이용되지 않을 참조(reference)를 말한다.

Stack 예제를 보면, 원소 index가 size보다 작은 곳에 있는 요소들은 실제 쓰이는 참조이지만,
나머지 영역에 있는 참조들은 그렇지 않다.  
이 경우 gc 입장에서는 어떤게 실제 사용하는 객체고, 사용하지 않는 것인지를 알 방법이 없다.

위와 같이 gc가 판단할 수 없는 경우 메모리 누수가 일어날 수 있다.

자동적으로 쓰레기 객체를 수집하는 언어에서 메모리 누수가 발생하면 찾기 어렵다.
이런 경우 해당 객체만 gc에서 제외되는 것이 아니라, 그 객체를 통해 참조되는 다른
객체들도 gc에서 제외된다.

### 해결 방법
가장 좋은 방법은 변수 scope를 최대한 좁게 만들면 대부분은 자연히 해결된다.  
scope로 해결할 수 없는 경우 불필요한 객체 참조는 null로 만들어 해결할 수 있다.

**객체 참조를 null 처리하는 것은 규범이기 보단 예외적인 조치이다.**  
따라서 null 처리는 자체적으로 관리하는 메모리가 있는 클래스를 만들 때 
잘 생각해서 사용하도록 하자.

### 메모리 누수가 자주 일어나는 곳
(1) 캐시, 객체 참조를 캐시 안에 넣어 놓고 잊어버리는 일이 많기 때문  
해결책 1: WeakHashMap을 가지고 캐시를 구현  
캐시 바깥에서 키를 참조하고 있을 때만 값을 보관하면 될 때 쓸 수 있는 전략이다.
키가 만기 참조가 되는 순간 캐시 안에 보관된 키-값 쌍은 자동으로 삭제되기 때문이다.

해결책 2: 일반적인 캐시 항목의 수명은 보관 기간  
백그라운드 스레드에 사용하지 않는 항목을 비우도록 처리하면 된다.
LinkedHashMap 클래스를 사용하면 편한데, removeEldestEntry 메서드를 제공하기 때문이다.
더 복합한 캐시라면 java.lang.ref를 직접 사용해야 할 수도 있다.

(2) 리스너(listener) 등의 역호출자(callback)  
콜백 기능을 제공하는 API를 사용하는 클라이언트가 콜백을 명시적으로 제거하지 않을 경우, 
적절한 조치를 취하기 전가지 메모리는 점유된 상태로 남아있게 된다.  
gc가 콜백을 즉시 처리하도록 하는 좋은 방법은, 콜백에 대한 약한 참조(weak reference)만
저장하는 것이다. WeakHashMap의 키로 저장하는 것이 그 예다.

### 힙 프로파일러(heap profiler)
메모리 누수는 보통 뚜렷한 오류로 이어지지 않아, 수년간 시스템에 남아 있는 경우도 있다.
이런 경우는 주의 깊게 코드를 검토하거나 힙 프로파일러 같은 도구를 통해 검증하다 발견된다.