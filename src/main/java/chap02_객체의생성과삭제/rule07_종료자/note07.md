## 종료자 사용을 피하라.
종료자(finalizer)는 예측 불가능하며, 대체로 위험하고, 일반적으로 불필요하다.
따라서 `종료자 사용은 피하는 것`이 `원칙`이다.

### 종료자는 정확한 명세가 없어 비결정적인 행동을 보일 수 있다.
종료자는 즉시 실행되리라는 보장이 전혀 없다.  
종료자는 gc 알고리즘에 좌우되는데, JVM 구현마다 크게 다르다.  

종료자의 더딘 실행은 단순히 이론적인 문제가 아니다.  
클래스에 종료자를 붙이면, 드문 일이지만 객체 메모리 반환이 지연될 수도 있다.  

종료자는 제대로 된 명세가 없다. 언제 어느 스레드가 실행해야되는지, 반드시 실행되어야
한다던지에 관한 것도 없다. 그래서 종료자가 실행되지 않은채로 프로그램이 끝나는 것도 가능하다.  
그래서 지속성이 보장되어야 하는 **중요 상태 정보는 종료자로 갱신하면 안 된다.**  

예를 들면, 분산 시스템에서 데이터베이스 같은 공유 자원에 대한 지속성 락을 종료자가 반환하게
하면 안 된다. 왜냐하면 종료자가 실행되지 않은채 프로그램이 끝나면 지속성 락을 반환하지 않게 되고,
전체 시스템에 락이 걸려 먹통이 될 수도 있기 때문이다.

### 종료자를 사용하면 프로그램 성능이 심각히 떨어진다.
책에 나온 내용이지만, 종료자를 사용해 객체를 삭제하는 프로그램은 430배 가량 느려졌다고
나와 있다.

### 파일, 스레드처럼 명시저거으로 반환하거나 삭제해야 하는 자원은 어떻게 해야하나?
> 명시적인 종료 메서드(termination method)를 하나 정의하고, 클라이언트가 호출하도록 한다.  

명심할 것은 종료 여부를 나타내는 private 필드를 하나 두고, 모든 메서드 맨 앞에
해당 필드를 검사하는 코드를 두어, 이미 종료된 객체에 메서드를 호출하면 
`IllegalStateException`이 던져지도록 해야 한다는 것이다.  
예로, OutputStream, InputStream, java.sql.Connection의 close 메서드가 있다.

이런 명시적 종료 메서드는 보통 `try-finally` 문과 함께 쓰인다. 객체 종료를 보장하기 위해서이다.
```java
// try-finally 블록을 통해 종료 메서드 실행 보장
// 자바 1.7부터는 try-with-resources 문을 지원한다.
Foo foo = new Foo();
try {
    // foo로 해야 하는 작업 수행
} finally {
    foo.terminate(); // 명시적 종료 메서드 호출
}
```

### 종료자가 사용되는 경우는?
(1) 명시적 종료 메서드 호출을 잊을 경우 대비하는 안전망 역할  
이 경우에 종료자는 그런 자원을 발견하게 될 경우 반드시 경고 메시지를 로그로 남겨야 한다.

(2) 네이티브 피어(native peer)와 연결된 객체를 다룰 때  
네이티브 피어란 일반 자바 객체가 네이티브 메서드를 통해 기능 수행을 위임하는 
네이티브 객체를 말한다.  

네이티브 피어는 일반 객체가 아니라, gc가 알 수 없으며 자바 측 피어 객체가 반환될 때
같이 반환할 수도 없다.  
네이티브 피어가 중요한 자원을 점유하고 있지 않다고 가정한다면, 종료자가 그런 객체 반환에
걸맞다. 하지만 네이티브 피어가 즉시 종료되어야 하는 자원을 포함한 경우에는 `명시적 종료 메서드`
를 클래스에 추가해야 한다.

### 종료자 연결은 자동으로 이루어지지 않는다.
종료자를 사용하게 될 경우 주의할 점이다. 이게 무슨 말이냐면 하위 클래스에서 상위 클래스의
종료자를 재정의(override)할 때, 상위 클래스의 종료자를 명시적으로 호출해야 한다는 것이다.
```java
// 수동 종료자 연결(Manual finalizer chaining)
@Override
protected void finalize() throws Throwable {
    try {
        // 하위 클래스 상태를 종료
    } finally {
        // 상위 클래스 종료자는 finally에서 호출해야 함.
        // 그래야 하위 클래스 종료 중에 예외가 발생해도, 상위 클래스 종료자는 호출되므로
        super.finalize();
    }
}
```

종료자 연결이 자동으로 이루어지는 문제를 방지하는 한 가지 방법은 모든 객체마다
여벌의 객체를 하나 더 만드는 것이다. 종료되어야 하는 객체 클래스 안에 종료자를 정의하는 대신,
`익명 클래스`안에 종료자를 정의하는 것이다.
```java
// 종료 보호자 숙어(Finalizer Guardian idiom)
public class Foo {
    // 이 객체는 바깥 객체(Foo 객체)를 종료시키는 역할만 한다.
    // 이런 익명 클래스를 종료 보호자(finalizer guardian)이라고 부른다.
    private final Object finalizerGuardian = new Object() {
        @Override
        protected void finalize() throws Throwable {
            // 바깥 Foo 객체를 종료시킴
        }
    };
    
    // 생략
}
```
어떻게 위의 **종료 보호자가 실행**되는걸까?  
바깥 객체에 대한 모든 참조가 사라지는 순간, 바깥 객체는 불필요 객체가 된다.
종료 보호자는 private 이므로 종료 보호자(익명 객체)도 불필요한 객체가 되고 
따라서 재정의한 익명 클래스의 종료자가 실행 가능한 상태가 된다.