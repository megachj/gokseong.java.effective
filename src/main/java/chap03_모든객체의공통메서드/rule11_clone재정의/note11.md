## Cloneable 인터페이스
> Cloneable은 어떤 객체가 복제(clone)를 허용한다는 사실을 알리려고, 고안된 
`믹스인(mixin) 인터페이스`이다.

### Cloneable 문제점
Cloneable은 인터페이스인데, clone 메서드를 가지고 있지 않고, Object의 clone 메서드는
protected로 선언되어 있다. 따라서 Cloneable을 구현하더라도 리플렉션을 사용해야만 
clone 메서드를 호출할 수 있다. 또 해당 객체에 clone 메서드를 구현하지 않았다면 리플렉션을
이용한 호출도 실패할 것이다.

### 그럼 Cloneable이 하는 일은?
하는 일은 protected로 선언된 Object의 clone 메서드가 어떻게 동작할지 정한다.  
* 어떤 클래스가 Cloneable을 구현하면, clone 메서드는 해당 객체를 필드 단위로
복사한 객체를 반환한다.
* Cloneable을 구현하지 않았다면, clone 메서드는 CloneNotSupportedException을 던진다.

일반적으로 인터페이스를 구현한다는 것은 클라이언트에게 해당 클래스가 할 수 있는 일을 알리는
것인데, Cloneable의 경우엔 상위 클래스의 protected 멤버가 어떻게 동작할지 규정하는 용도로 
쓰이고 있다.

이 말은, Cloneable 인터페이스를 구현해 결과를 얻으려면, 해당 클래스뿐 아니라
모든 상위 클래스들도 복잡하고, 강제적이지 않고, 문서도 부족한 프로토콜을 따라야 한다.

### clone 메서드의 일반 규약
java.lang.Object의 명세는 아래와 같다.
1. 객체의 복사본을 만들어 반환한다. "복사"의 의미는 클래스마다 다르다.  
일반적으로 다음 조건이 충족되어야 한다. 객체 x가 있다고 할때,  
    1. x.clone() != x 이 조건은 참이어야 한다.  
    2. x.clone().getClass() == x.getClass() 보통 참이 겠지만, 반드시 참일 필요는 없다.  
    3. x.clone().equals(x) 보통 참이겠지만, 반드시 참일 필요는 없다.
2. 객체를 복사하면 보통 같은 클래스의 새로운 객체가 만들어지는데, 내부 자료구조까지 복사해야
될 수도 있다.
3. 어떤 생성자도 호출되지 않는다.

이 규약은 아래와 같은 문제가 있다.  

(1) 3번 어떤 생성자도 호출되지 않는다는 규정은 너무 엄격하다.
* 클래스가 final로 선언되어 있다면, 하위 클래스가 없으므로 하위 객체에서 super.clone()하는 
경우가 없다. 이는 생성자로 만든 객체를 반환하도록 clone을 구현할 수도 있다는 말이 된다. (1-2번 조건 충족)
* 객체의 내부 멤버 변수들은 생성자로 만들어도 문제가 없을 것이다.