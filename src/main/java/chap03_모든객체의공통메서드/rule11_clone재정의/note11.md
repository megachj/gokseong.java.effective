## Object.clone 메서드에 대해서
> Object의 clone 메서드는 다른 언어로 구현된 JNI(Java Native Interface)
이다. 
* 이 메서드는 해당 객체의 메모리를 카피해서 만들고, 똑같은 값으로 할당해서
반환한다. (C언어로 생각하면 memcpy 라고 생각하면 됨)
* 만약 해당 객체에 참조형 변수가 있다면, 원본과 같은 객체를 참조하게 되어 원본성 유지에
문제가 생길 수 있다.

## Cloneable 인터페이스
> Cloneable은 어떤 객체가 복제(clone)를 허용한다는 사실을 알리려고, 고안된 
`믹스인(mixin) 인터페이스`이다.

### Cloneable 문제점
Cloneable은 인터페이스인데, clone 메서드를 가지고 있지 않고, Object의 clone 메서드는
protected로 선언되어 있다. 따라서 Cloneable을 구현하더라도 리플렉션을 사용해야만 
clone 메서드를 호출할 수 있다. 또 해당 객체에 clone 메서드를 구현하지 않았다면 리플렉션을
이용한 호출도 실패할 것이다.

### 그럼 Cloneable이 하는 일은?
하는 일은 protected로 선언된 Object의 clone 메서드가 어떻게 동작할지 정한다.  
* 어떤 클래스가 Cloneable을 구현하면, clone 메서드는 해당 객체를 필드 단위로
복사한 객체를 반환한다.
* Cloneable을 구현하지 않았다면, clone 메서드는 CloneNotSupportedException을 던진다.

일반적으로 인터페이스를 구현한다는 것은 클라이언트에게 해당 클래스가 할 수 있는 일을 알리는
것인데, Cloneable의 경우엔 상위 클래스의 protected 멤버가 어떻게 동작할지 규정하는 용도로 
쓰이고 있다.

이 말은, Cloneable 인터페이스를 구현해 결과를 얻으려면, 해당 클래스뿐 아니라
모든 상위 클래스들도 복잡하고, 강제적이지 않고, 문서도 부족한 프로토콜을 따라야 한다.

### clone 메서드의 일반 규약
java.lang.Object의 명세는 아래와 같다.
1. 객체의 복사본을 만들어 반환한다. "복사"의 의미는 클래스마다 다르다.  
일반적으로 다음 조건이 충족되어야 한다. 객체 x가 있다고 할때,  
    1. x.clone() != x 이 조건은 참이어야 한다.  
    2. x.clone().getClass() == x.getClass() 보통 참이 겠지만, 반드시 참일 필요는 없다.  
    3. x.clone().equals(x) 보통 참이겠지만, 반드시 참일 필요는 없다.
2. 객체를 복사하면 보통 같은 클래스의 새로운 객체가 만들어지는데, 내부 자료구조까지 복사해야
될 수도 있다.
3. 어떤 생성자도 호출되지 않는다.

이 규약은 아래와 같은 문제가 있다.  

(1) 3번 어떤 생성자도 호출되지 않는다는 규정은 너무 엄격하다.
* 클래스가 final로 선언되어 있다면, 하위 클래스가 없으므로 하위 객체에서 super.clone()하는 
경우가 없다. 이는 생성자로 만든 객체를 반환하도록 clone을 구현할 수도 있다는 말이 된다. (1-2번 조건 충족)
* 객체의 내부 멤버 변수들은 생성자로 만들어도 문제가 없을 것이다.

(2) 1-2번 조건은 너무 느슨하다. 왜냐하면, 해당 클래스를 clone했는데
만약 다른 클래스의 객체가 나온다면, 예상과 다를것이기 때문이다.
* 이를 해결하려면, 모든 연결된 상위 클래스들이 Object.clone을 부르도록 구현이 되어 있어야 한다.

결론적으로 아래 내용을 고려해야 한다.
* Object.clone이 호출되어야 하므로 상위 클래스의 clone 메서드가 잘 정의되어 있는지 확인
* Object.clone은 메모리만 복사하는 것이므로, 얕은 복사를 해결하지 않는다.
깊은 복사가 필요하다면 잘 구현해줘야 한다.

## 결론
위와 같이 많은 제약이 있어서, cloneable을 구현해 clone을 제공하지 않는게 좋다.
객체 복제를 지원하는 좋은 방법은, `복사 생성자`나 `복사 팩터리`를 제공하는 것이다.
```java
// 복사 생성자
public Yum(Yum yum);

// 복사 팩터리
public static Yum newInstance(Yum yum);
```

결국은 객체를 복사하는게 목적인데, clone 을 사용하면 아래처럼 안 좋은점들이 너무 많다.
* 언어 외적 객체 생성 수단에 의존(JNI)
* 제대로 문서화되어 있지 않음
* 규약이 느슨하거나 강압적임
* 복사하려는 객체에 final 필드가 있으면 처리할 수가 없음
* 불필요한 예외 검사, 형 변환