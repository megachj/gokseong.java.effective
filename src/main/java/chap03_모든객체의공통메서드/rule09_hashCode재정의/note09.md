## hashCode의 일반 규약
**equals 메서드를 재정의한 클래스는 반드시 hashCode 메서드도 재정의 해야 한다.**  
그렇지 않으면 Object.hashCode의 일반 규약을 어기게 되어, HashMap, HashSet, Hashtable
같은 해시 기반 컬렉션과 함께 사용하면 오동작하게 된다.
* 런타임 중에 같은 객체의 hashCode를 여러 번 호출하더라도 정보들이 변경되지 않았다면
언제나 동일한 정수(integer)가 반환되어야 한다. 프로그램 종료 후 다시 실행했을 때 숫자가
같을 필요는 없다.
* equals(Object) 메서드가 같다고 판정한 두 객체의 hashCode 값은 같아야 한다.
* equals(Object) 메서드가 다르다고 판정한 두 객체의 hashCode 값이 꼭 다를 필요는 없다.
하지만 다르게 나오면 해시 테이블 성능이 향상될 수 있다.

equals를 재정의하고, hashCode를 재정의하지 않으면 2번째를 위반하게 된다. 왜냐하면
논리적으로 같은 객체를 같다라고 재정의했지만, hashCode는 재정의 되지 않으면
객체 동일성을 가지고 판단했으므로, 다른 해시값이 나오게 되기 때문이다.  
PhnoeNumber 클래스를 예로 확인할 수 있다.

## 이상적인 해시 함수에 '가까운' 함수를 만드는 지침
1. 17과 같은 0 아닌 상수를 result라는 이름의 int 변수에 저장한다.
2. equals 메서드가 사용하는 모든 필드 f에 대해 아래 절차를 시행한다.
    1. 해당 필드에 대한 int 해시 코드 c를 계산한다.
        1. 필드가 boolean이면, (f ? 1 : 0)
        2. 필드가 byte, char, short, int 중 하나이면, (int) f
        3. 필드가 long이면, (int) (f ^ (f >>> 32))
        4. 필드가 float이면, Float.floatToIntBits(f)
        5. 필드가 double이면, Double.doubleToLongBits(f) 를 계산하고,  
        결과 long값을 위 3번 절차를 따라 해시 코드로 변환
        6. 필드가 객체 참조이고 equals가 해당 필드의 equals를 재귀적으로 호출하는 경우,  
        hashCode 또한 재귀적으로 호출해 해시코드를 계산한다. 좀 더 복잡한 비교가 필요한  
        경우에는 대표 형태를 만들어 hashCode를 호출한다.  
        필드가 null인 경우는 상수(보통 0)을 반환한다.
        7. 필드가 배열인 경우, 각 원소가 별도 필드인 것처럼 계산한다.  
        배열 내 모든 원소가 중요한 경우 JDK 1.5부터 제공되는 Arrays.hashCode 메서드 중 
        하나를 사용할 수도 있다.
    2. 해시 코드 c를 result에 다음처럼 결합한다.  
    result = 31 * result + c;
3. result를 반환한다.
4. 동치 관계에 있는 객체 해시 코드 값이 똑같은지 점검한다.

위 방법이 가장 좋은 해시 함수라고는 할 수 없지만, 간단하며 꽤 쓸만한 해시 함수이다.  
이런것들은 수학자, 이론 컴퓨터과학자의 연구 주제이다.  
꼭 알아야 할 것은, **객체 중요 부분을 해시 코드 계산 과정에서 생략하면 안된다**라는 것이다.  
해시 충돌이 날 가능성이 높아져, 성능이 떨어질 수 있기 때문이다.   